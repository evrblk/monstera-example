// Code generated by `monstera generate`. DO NOT EDIT.

package monsteraexample

import (
	monstera "github.com/evrblk/monstera"
	corepb "github.com/evrblk/monstera-example/corepb"
	monsterax "github.com/evrblk/monstera/x"
	proto "google.golang.org/protobuf/proto"
	"io"
)

type AccountsCoreAdapter struct {
	accountsCore AccountsCoreApi
}

var _ monstera.ApplicationCore = &AccountsCoreAdapter{}

func NewAccountsCoreAdapter(accountsCore AccountsCoreApi) *AccountsCoreAdapter {
	return &AccountsCoreAdapter{accountsCore: accountsCore}
}

func (a *AccountsCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	return a.accountsCore.Snapshot()
}

func (a *AccountsCoreAdapter) Restore(r io.ReadCloser) error {
	return a.accountsCore.Restore(r)
}

func (a *AccountsCoreAdapter) Close() {
	a.accountsCore.Close()
}

func (a *AccountsCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.UpdateRequest{}
	updateResponse := &corepb.UpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	switch req := updateRequest.Request.(type) {
	case *corepb.UpdateRequest_CreateAccountRequest:
		r, err := a.accountsCore.CreateAccount(req.CreateAccountRequest)
		updateResponse.Response = &corepb.UpdateResponse_CreateAccountResponse{CreateAccountResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_UpdateAccountRequest:
		r, err := a.accountsCore.UpdateAccount(req.UpdateAccountRequest)
		updateResponse.Response = &corepb.UpdateResponse_UpdateAccountResponse{UpdateAccountResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_DeleteAccountRequest:
		r, err := a.accountsCore.DeleteAccount(req.DeleteAccountRequest)
		updateResponse.Response = &corepb.UpdateResponse_DeleteAccountResponse{DeleteAccountResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *AccountsCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.ReadRequest{}
	readResponse := &corepb.ReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	switch req := readRequest.Request.(type) {
	case *corepb.ReadRequest_ListAccountsRequest:
		r, err := a.accountsCore.ListAccounts(req.ListAccountsRequest)
		readResponse.Response = &corepb.ReadResponse_ListAccountsResponse{ListAccountsResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	case *corepb.ReadRequest_GetAccountRequest:
		r, err := a.accountsCore.GetAccount(req.GetAccountRequest)
		readResponse.Response = &corepb.ReadResponse_GetAccountResponse{GetAccountResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}

type LocksCoreAdapter struct {
	locksCore LocksCoreApi
}

var _ monstera.ApplicationCore = &LocksCoreAdapter{}

func NewLocksCoreAdapter(locksCore LocksCoreApi) *LocksCoreAdapter {
	return &LocksCoreAdapter{locksCore: locksCore}
}

func (a *LocksCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	return a.locksCore.Snapshot()
}

func (a *LocksCoreAdapter) Restore(r io.ReadCloser) error {
	return a.locksCore.Restore(r)
}

func (a *LocksCoreAdapter) Close() {
	a.locksCore.Close()
}

func (a *LocksCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.UpdateRequest{}
	updateResponse := &corepb.UpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	switch req := updateRequest.Request.(type) {
	case *corepb.UpdateRequest_AcquireLockRequest:
		r, err := a.locksCore.AcquireLock(req.AcquireLockRequest)
		updateResponse.Response = &corepb.UpdateResponse_AcquireLockResponse{AcquireLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_ReleaseLockRequest:
		r, err := a.locksCore.ReleaseLock(req.ReleaseLockRequest)
		updateResponse.Response = &corepb.UpdateResponse_ReleaseLockResponse{ReleaseLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_DeleteLockRequest:
		r, err := a.locksCore.DeleteLock(req.DeleteLockRequest)
		updateResponse.Response = &corepb.UpdateResponse_DeleteLockResponse{DeleteLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_GetLockRequest:
		r, err := a.locksCore.GetLock(req.GetLockRequest)
		updateResponse.Response = &corepb.UpdateResponse_GetLockResponse{GetLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *LocksCoreAdapter) Read(request []byte) []byte {
	panic("no matching handlers")
}

type NamespacesCoreAdapter struct {
	namespacesCore NamespacesCoreApi
}

var _ monstera.ApplicationCore = &NamespacesCoreAdapter{}

func NewNamespacesCoreAdapter(namespacesCore NamespacesCoreApi) *NamespacesCoreAdapter {
	return &NamespacesCoreAdapter{namespacesCore: namespacesCore}
}

func (a *NamespacesCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	return a.namespacesCore.Snapshot()
}

func (a *NamespacesCoreAdapter) Restore(r io.ReadCloser) error {
	return a.namespacesCore.Restore(r)
}

func (a *NamespacesCoreAdapter) Close() {
	a.namespacesCore.Close()
}

func (a *NamespacesCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.UpdateRequest{}
	updateResponse := &corepb.UpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	switch req := updateRequest.Request.(type) {
	case *corepb.UpdateRequest_CreateNamespaceRequest:
		r, err := a.namespacesCore.CreateNamespace(req.CreateNamespaceRequest)
		updateResponse.Response = &corepb.UpdateResponse_CreateNamespaceResponse{CreateNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_UpdateNamespaceRequest:
		r, err := a.namespacesCore.UpdateNamespace(req.UpdateNamespaceRequest)
		updateResponse.Response = &corepb.UpdateResponse_UpdateNamespaceResponse{UpdateNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.UpdateRequest_DeleteNamespaceRequest:
		r, err := a.namespacesCore.DeleteNamespace(req.DeleteNamespaceRequest)
		updateResponse.Response = &corepb.UpdateResponse_DeleteNamespaceResponse{DeleteNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *NamespacesCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.ReadRequest{}
	readResponse := &corepb.ReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	switch req := readRequest.Request.(type) {
	case *corepb.ReadRequest_GetNamespaceRequest:
		r, err := a.namespacesCore.GetNamespace(req.GetNamespaceRequest)
		readResponse.Response = &corepb.ReadResponse_GetNamespaceResponse{GetNamespaceResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	case *corepb.ReadRequest_ListNamespacesRequest:
		r, err := a.namespacesCore.ListNamespaces(req.ListNamespacesRequest)
		readResponse.Response = &corepb.ReadResponse_ListNamespacesResponse{ListNamespacesResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}
