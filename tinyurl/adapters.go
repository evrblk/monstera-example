// Code generated by `monstera generate`. DO NOT EDIT.

package tinyurl

import (
	monstera "github.com/evrblk/monstera"
	corepb "github.com/evrblk/monstera-example/tinyurl/corepb"
	monsterax "github.com/evrblk/monstera/x"
	proto "google.golang.org/protobuf/proto"
	"io"
)

type ShortUrlsCoreAdapter struct {
	shortUrlsCore ShortUrlsCoreApi
}

var _ monstera.ApplicationCore = &ShortUrlsCoreAdapter{}

func NewShortUrlsCoreAdapter(shortUrlsCore ShortUrlsCoreApi) *ShortUrlsCoreAdapter {
	return &ShortUrlsCoreAdapter{shortUrlsCore: shortUrlsCore}
}

func (a *ShortUrlsCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	return a.shortUrlsCore.Snapshot()
}

func (a *ShortUrlsCoreAdapter) Restore(r io.ReadCloser) error {
	return a.shortUrlsCore.Restore(r)
}

func (a *ShortUrlsCoreAdapter) Close() {
	a.shortUrlsCore.Close()
}

func (a *ShortUrlsCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.UpdateRequest{}
	updateResponse := &corepb.UpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	switch req := updateRequest.Request.(type) {
	case *corepb.UpdateRequest_CreateShortUrlRequest:
		r, err := a.shortUrlsCore.CreateShortUrl(req.CreateShortUrlRequest)
		updateResponse.Response = &corepb.UpdateResponse_CreateShortUrlResponse{CreateShortUrlResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *ShortUrlsCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.ReadRequest{}
	readResponse := &corepb.ReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	switch req := readRequest.Request.(type) {
	case *corepb.ReadRequest_GetShortUrlRequest:
		r, err := a.shortUrlsCore.GetShortUrl(req.GetShortUrlRequest)
		readResponse.Response = &corepb.ReadResponse_GetShortUrlResponse{GetShortUrlResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	case *corepb.ReadRequest_ListShortUrlsRequest:
		r, err := a.shortUrlsCore.ListShortUrls(req.ListShortUrlsRequest)
		readResponse.Response = &corepb.ReadResponse_ListShortUrlsResponse{ListShortUrlsResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}

type UsersCoreAdapter struct {
	usersCore UsersCoreApi
}

var _ monstera.ApplicationCore = &UsersCoreAdapter{}

func NewUsersCoreAdapter(usersCore UsersCoreApi) *UsersCoreAdapter {
	return &UsersCoreAdapter{usersCore: usersCore}
}

func (a *UsersCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	return a.usersCore.Snapshot()
}

func (a *UsersCoreAdapter) Restore(r io.ReadCloser) error {
	return a.usersCore.Restore(r)
}

func (a *UsersCoreAdapter) Close() {
	a.usersCore.Close()
}

func (a *UsersCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.UpdateRequest{}
	updateResponse := &corepb.UpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	switch req := updateRequest.Request.(type) {
	case *corepb.UpdateRequest_CreateUserRequest:
		r, err := a.usersCore.CreateUser(req.CreateUserRequest)
		updateResponse.Response = &corepb.UpdateResponse_CreateUserResponse{CreateUserResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *UsersCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.ReadRequest{}
	readResponse := &corepb.ReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	switch req := readRequest.Request.(type) {
	case *corepb.ReadRequest_GetUserRequest:
		r, err := a.usersCore.GetUser(req.GetUserRequest)
		readResponse.Response = &corepb.ReadResponse_GetUserResponse{GetUserResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}
