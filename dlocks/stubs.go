// Code generated by `monstera generate`. DO NOT EDIT.

package dlocks

import (
	"context"
	monstera "github.com/evrblk/monstera"
	corepb "github.com/evrblk/monstera-example/dlocks/corepb"
	monsterax "github.com/evrblk/monstera/x"
	proto "google.golang.org/protobuf/proto"
	"sync"
)

type LocksServiceMonsteraShardKeyCalculator interface {
	ListAccountsShardKey(request *corepb.ListAccountsRequest) []byte
	GetAccountShardKey(request *corepb.GetAccountRequest) []byte
	CreateAccountShardKey(request *corepb.CreateAccountRequest) []byte
	UpdateAccountShardKey(request *corepb.UpdateAccountRequest) []byte
	DeleteAccountShardKey(request *corepb.DeleteAccountRequest) []byte

	GetNamespaceShardKey(request *corepb.GetNamespaceRequest) []byte
	ListNamespacesShardKey(request *corepb.ListNamespacesRequest) []byte
	CreateNamespaceShardKey(request *corepb.CreateNamespaceRequest) []byte
	UpdateNamespaceShardKey(request *corepb.UpdateNamespaceRequest) []byte
	DeleteNamespaceShardKey(request *corepb.DeleteNamespaceRequest) []byte

	AcquireLockShardKey(request *corepb.AcquireLockRequest) []byte
	ReleaseLockShardKey(request *corepb.ReleaseLockRequest) []byte
	DeleteLockShardKey(request *corepb.DeleteLockRequest) []byte
	GetLockShardKey(request *corepb.GetLockRequest) []byte
}

type LocksServiceCoreApiMonsteraStub struct {
	monsteraClient     *monstera.MonsteraClient
	shardKeyCalculator LocksServiceMonsteraShardKeyCalculator
}

var _ LocksServiceCoreApi = &LocksServiceCoreApiMonsteraStub{}

func (s *LocksServiceCoreApiMonsteraStub) ListAccounts(ctx context.Context, request *corepb.ListAccountsRequest) (*corepb.ListAccountsResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_ListAccountsRequest{ListAccountsRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListAccountsShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Accounts", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_ListAccountsResponse)
	if ok {
		return response.ListAccountsResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) GetAccount(ctx context.Context, request *corepb.GetAccountRequest) (*corepb.GetAccountResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_GetAccountRequest{GetAccountRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetAccountShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Accounts", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_GetAccountResponse)
	if ok {
		return response.GetAccountResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) CreateAccount(ctx context.Context, request *corepb.CreateAccountRequest) (*corepb.CreateAccountResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_CreateAccountRequest{CreateAccountRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateAccountShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_CreateAccountResponse)
	if ok {
		return response.CreateAccountResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) UpdateAccount(ctx context.Context, request *corepb.UpdateAccountRequest) (*corepb.UpdateAccountResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_UpdateAccountRequest{UpdateAccountRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.UpdateAccountShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_UpdateAccountResponse)
	if ok {
		return response.UpdateAccountResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) DeleteAccount(ctx context.Context, request *corepb.DeleteAccountRequest) (*corepb.DeleteAccountResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_DeleteAccountRequest{DeleteAccountRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteAccountShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_DeleteAccountResponse)
	if ok {
		return response.DeleteAccountResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) GetNamespace(ctx context.Context, request *corepb.GetNamespaceRequest) (*corepb.GetNamespaceResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_GetNamespaceRequest{GetNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Namespaces", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_GetNamespaceResponse)
	if ok {
		return response.GetNamespaceResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) ListNamespaces(ctx context.Context, request *corepb.ListNamespacesRequest) (*corepb.ListNamespacesResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_ListNamespacesRequest{ListNamespacesRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListNamespacesShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Namespaces", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_ListNamespacesResponse)
	if ok {
		return response.ListNamespacesResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) CreateNamespace(ctx context.Context, request *corepb.CreateNamespaceRequest) (*corepb.CreateNamespaceResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_CreateNamespaceRequest{CreateNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Namespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_CreateNamespaceResponse)
	if ok {
		return response.CreateNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) UpdateNamespace(ctx context.Context, request *corepb.UpdateNamespaceRequest) (*corepb.UpdateNamespaceResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_UpdateNamespaceRequest{UpdateNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.UpdateNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Namespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_UpdateNamespaceResponse)
	if ok {
		return response.UpdateNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) DeleteNamespace(ctx context.Context, request *corepb.DeleteNamespaceRequest) (*corepb.DeleteNamespaceResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_DeleteNamespaceRequest{DeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Namespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_DeleteNamespaceResponse)
	if ok {
		return response.DeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) AcquireLock(ctx context.Context, request *corepb.AcquireLockRequest) (*corepb.AcquireLockResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_AcquireLockRequest{AcquireLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AcquireLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Locks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_AcquireLockResponse)
	if ok {
		return response.AcquireLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) ReleaseLock(ctx context.Context, request *corepb.ReleaseLockRequest) (*corepb.ReleaseLockResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_ReleaseLockRequest{ReleaseLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ReleaseLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Locks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_ReleaseLockResponse)
	if ok {
		return response.ReleaseLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) DeleteLock(ctx context.Context, request *corepb.DeleteLockRequest) (*corepb.DeleteLockResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_DeleteLockRequest{DeleteLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Locks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_DeleteLockResponse)
	if ok {
		return response.DeleteLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LocksServiceCoreApiMonsteraStub) GetLock(ctx context.Context, request *corepb.GetLockRequest) (*corepb.GetLockResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_GetLockRequest{GetLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Locks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_GetLockResponse)
	if ok {
		return response.GetLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func NewLocksServiceCoreApiMonsteraStub(monsteraClient *monstera.MonsteraClient, shardKeyCalculator LocksServiceMonsteraShardKeyCalculator) *LocksServiceCoreApiMonsteraStub {
	return &LocksServiceCoreApiMonsteraStub{monsteraClient: monsteraClient, shardKeyCalculator: shardKeyCalculator}
}

func nilifyIfEmpty(err *monsterax.Error) error {
	if err == nil || err.Code == monsterax.ErrorCode_INVALID || err.Code == monsterax.ErrorCode_OK {
		return nil
	} else {
		return err
	}
}

type LocksServiceCoreApiStandaloneStub struct {
	accountsCore   AccountsCoreApi
	namespacesCore NamespacesCoreApi
	locksCore      LocksCoreApi

	mu sync.RWMutex
}

var _ LocksServiceCoreApi = &LocksServiceCoreApiStandaloneStub{}

func (s *LocksServiceCoreApiStandaloneStub) ListAccounts(ctx context.Context, request *corepb.ListAccountsRequest) (*corepb.ListAccountsResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.accountsCore.ListAccounts(request)
}

func (s *LocksServiceCoreApiStandaloneStub) GetAccount(ctx context.Context, request *corepb.GetAccountRequest) (*corepb.GetAccountResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.accountsCore.GetAccount(request)
}

func (s *LocksServiceCoreApiStandaloneStub) CreateAccount(ctx context.Context, request *corepb.CreateAccountRequest) (*corepb.CreateAccountResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.CreateAccount(request)
}

func (s *LocksServiceCoreApiStandaloneStub) UpdateAccount(ctx context.Context, request *corepb.UpdateAccountRequest) (*corepb.UpdateAccountResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.UpdateAccount(request)
}

func (s *LocksServiceCoreApiStandaloneStub) DeleteAccount(ctx context.Context, request *corepb.DeleteAccountRequest) (*corepb.DeleteAccountResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.DeleteAccount(request)
}

func (s *LocksServiceCoreApiStandaloneStub) GetNamespace(ctx context.Context, request *corepb.GetNamespaceRequest) (*corepb.GetNamespaceResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.namespacesCore.GetNamespace(request)
}

func (s *LocksServiceCoreApiStandaloneStub) ListNamespaces(ctx context.Context, request *corepb.ListNamespacesRequest) (*corepb.ListNamespacesResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.namespacesCore.ListNamespaces(request)
}

func (s *LocksServiceCoreApiStandaloneStub) CreateNamespace(ctx context.Context, request *corepb.CreateNamespaceRequest) (*corepb.CreateNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.namespacesCore.CreateNamespace(request)
}

func (s *LocksServiceCoreApiStandaloneStub) UpdateNamespace(ctx context.Context, request *corepb.UpdateNamespaceRequest) (*corepb.UpdateNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.namespacesCore.UpdateNamespace(request)
}

func (s *LocksServiceCoreApiStandaloneStub) DeleteNamespace(ctx context.Context, request *corepb.DeleteNamespaceRequest) (*corepb.DeleteNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.namespacesCore.DeleteNamespace(request)
}

func (s *LocksServiceCoreApiStandaloneStub) AcquireLock(ctx context.Context, request *corepb.AcquireLockRequest) (*corepb.AcquireLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.locksCore.AcquireLock(request)
}

func (s *LocksServiceCoreApiStandaloneStub) ReleaseLock(ctx context.Context, request *corepb.ReleaseLockRequest) (*corepb.ReleaseLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.locksCore.ReleaseLock(request)
}

func (s *LocksServiceCoreApiStandaloneStub) DeleteLock(ctx context.Context, request *corepb.DeleteLockRequest) (*corepb.DeleteLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.locksCore.DeleteLock(request)
}

func (s *LocksServiceCoreApiStandaloneStub) GetLock(ctx context.Context, request *corepb.GetLockRequest) (*corepb.GetLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.locksCore.GetLock(request)
}

func NewLocksServiceCoreApiStandaloneStub(accountsCore AccountsCoreApi, namespacesCore NamespacesCoreApi, locksCore LocksCoreApi) *LocksServiceCoreApiStandaloneStub {
	return &LocksServiceCoreApiStandaloneStub{accountsCore: accountsCore, namespacesCore: namespacesCore, locksCore: locksCore}
}
