// Code generated by `monstera generate`. DO NOT EDIT.

package ledger

import (
	"context"
	monstera "github.com/evrblk/monstera"
	corepb "github.com/evrblk/monstera-example/ledger/corepb"
	monsterax "github.com/evrblk/monstera/x"
	proto "google.golang.org/protobuf/proto"
	"sync"
)

type LedgerServiceMonsteraShardKeyCalculator interface {
	ListTransactionsShardKey(request *corepb.ListTransactionsRequest) []byte
	GetTransactionShardKey(request *corepb.GetTransactionRequest) []byte
	GetAccountShardKey(request *corepb.GetAccountRequest) []byte
	CreateTransactionShardKey(request *corepb.CreateTransactionRequest) []byte
	CancelTransactionShardKey(request *corepb.CancelTransactionRequest) []byte
	SettleTransactionShardKey(request *corepb.SettleTransactionRequest) []byte
	CreateAccountShardKey(request *corepb.CreateAccountRequest) []byte
}

type LedgerServiceCoreApiMonsteraStub struct {
	monsteraClient     *monstera.MonsteraClient
	shardKeyCalculator LedgerServiceMonsteraShardKeyCalculator
}

var _ LedgerServiceCoreApi = &LedgerServiceCoreApiMonsteraStub{}

func (s *LedgerServiceCoreApiMonsteraStub) ListTransactions(ctx context.Context, request *corepb.ListTransactionsRequest) (*corepb.ListTransactionsResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_ListTransactionsRequest{ListTransactionsRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListTransactionsShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Accounts", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_ListTransactionsResponse)
	if ok {
		return response.ListTransactionsResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LedgerServiceCoreApiMonsteraStub) GetTransaction(ctx context.Context, request *corepb.GetTransactionRequest) (*corepb.GetTransactionResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_GetTransactionRequest{GetTransactionRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetTransactionShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Accounts", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_GetTransactionResponse)
	if ok {
		return response.GetTransactionResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LedgerServiceCoreApiMonsteraStub) GetAccount(ctx context.Context, request *corepb.GetAccountRequest) (*corepb.GetAccountResponse, error) {
	readRequest := &corepb.ReadRequest{Request: &corepb.ReadRequest_GetAccountRequest{GetAccountRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetAccountShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "Accounts", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.ReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.ReadResponse_GetAccountResponse)
	if ok {
		return response.GetAccountResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *LedgerServiceCoreApiMonsteraStub) CreateTransaction(ctx context.Context, request *corepb.CreateTransactionRequest) (*corepb.CreateTransactionResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_CreateTransactionRequest{CreateTransactionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateTransactionShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_CreateTransactionResponse)
	if ok {
		return response.CreateTransactionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LedgerServiceCoreApiMonsteraStub) CancelTransaction(ctx context.Context, request *corepb.CancelTransactionRequest) (*corepb.CancelTransactionResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_CancelTransactionRequest{CancelTransactionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CancelTransactionShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_CancelTransactionResponse)
	if ok {
		return response.CancelTransactionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LedgerServiceCoreApiMonsteraStub) SettleTransaction(ctx context.Context, request *corepb.SettleTransactionRequest) (*corepb.SettleTransactionResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_SettleTransactionRequest{SettleTransactionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.SettleTransactionShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_SettleTransactionResponse)
	if ok {
		return response.SettleTransactionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *LedgerServiceCoreApiMonsteraStub) CreateAccount(ctx context.Context, request *corepb.CreateAccountRequest) (*corepb.CreateAccountResponse, error) {
	updateRequest := &corepb.UpdateRequest{Request: &corepb.UpdateRequest_CreateAccountRequest{CreateAccountRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateAccountShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "Accounts", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.UpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.UpdateResponse_CreateAccountResponse)
	if ok {
		return response.CreateAccountResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func NewLedgerServiceCoreApiMonsteraStub(monsteraClient *monstera.MonsteraClient, shardKeyCalculator LedgerServiceMonsteraShardKeyCalculator) *LedgerServiceCoreApiMonsteraStub {
	return &LedgerServiceCoreApiMonsteraStub{monsteraClient: monsteraClient, shardKeyCalculator: shardKeyCalculator}
}

func nilifyIfEmpty(err *monsterax.Error) error {
	if err == nil || err.Code == monsterax.ErrorCode_INVALID || err.Code == monsterax.ErrorCode_OK {
		return nil
	} else {
		return err
	}
}

type LedgerServiceCoreApiStandaloneStub struct {
	accountsCore AccountsCoreApi

	mu sync.RWMutex
}

var _ LedgerServiceCoreApi = &LedgerServiceCoreApiStandaloneStub{}

func (s *LedgerServiceCoreApiStandaloneStub) ListTransactions(ctx context.Context, request *corepb.ListTransactionsRequest) (*corepb.ListTransactionsResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.accountsCore.ListTransactions(request)
}

func (s *LedgerServiceCoreApiStandaloneStub) GetTransaction(ctx context.Context, request *corepb.GetTransactionRequest) (*corepb.GetTransactionResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.accountsCore.GetTransaction(request)
}

func (s *LedgerServiceCoreApiStandaloneStub) GetAccount(ctx context.Context, request *corepb.GetAccountRequest) (*corepb.GetAccountResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.accountsCore.GetAccount(request)
}

func (s *LedgerServiceCoreApiStandaloneStub) CreateTransaction(ctx context.Context, request *corepb.CreateTransactionRequest) (*corepb.CreateTransactionResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.CreateTransaction(request)
}

func (s *LedgerServiceCoreApiStandaloneStub) CancelTransaction(ctx context.Context, request *corepb.CancelTransactionRequest) (*corepb.CancelTransactionResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.CancelTransaction(request)
}

func (s *LedgerServiceCoreApiStandaloneStub) SettleTransaction(ctx context.Context, request *corepb.SettleTransactionRequest) (*corepb.SettleTransactionResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.SettleTransaction(request)
}

func (s *LedgerServiceCoreApiStandaloneStub) CreateAccount(ctx context.Context, request *corepb.CreateAccountRequest) (*corepb.CreateAccountResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.accountsCore.CreateAccount(request)
}

func NewLedgerServiceCoreApiStandaloneStub(accountsCore AccountsCoreApi) *LedgerServiceCoreApiStandaloneStub {
	return &LedgerServiceCoreApiStandaloneStub{accountsCore: accountsCore}
}
